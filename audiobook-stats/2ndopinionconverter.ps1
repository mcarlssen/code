<#

# 2ndOpinion Report Formatter (CSV)

This script is used to convert report files generated by Steven Jay Cohen's `2nd Opinion` software, into CSV format.
2nd Opinion is used to check a set of audio files against Audible QC standards for things like peak volume, RMS, noise floor, etc.
It generates a text file at the end of its scan, which is saved next to the audio files. This script converts that text file to CSV.

## SCRIPT FLOW:
- Recursively scans for any files in current or child folders called '2ndOpinion-Report.txt' and notes any found.
- If reports are found, it opens each one as a powershell object so that certain lines can be discarded quickly.
- It then converts the object to a string for CSV formatting via 'ReplaceStringWithCommas'. This does add comma delimiters, 
	but also removes additional text from the file that makes the CSV file impossible to perform math functions on.
- It adds a header to the beginning of the string so that Excel knows how to import it. If many reports will be processed
	and combined into one large one, this line can be commented out (search for '$csvHeader').
- 2nd Opinion adds a "summary" blob at the bottom of the report which is unnecessary for our purposes. This is trimmed.
- Lastly, the resultant well-formed CSV data is output to a CSV file in the same directory as the 2nd Opinion report it matches.

## USAGE

Execute script in a powershell prompt at the root level of all folders which may contain 2nd-Opinion report files. 
Script will output CSV version alongside each 2nd-Opinion file found, in their respective directories.

# changelog

## 0.1.1 fixed bug in CSV formatting.
## 0.1.0 first edition 6/12/23.

## NOTES

Script written by Magnus Carlssen. Released as public domain.
Please don't copy my code - not because it's good, but because it's terrible.
Please send bug reports or feature improvements to magnus@carlssen.co.uk.

https://carlssen.co.uk

#>

Clear-Host 

$inputFile = "2ndOpinion-Report.txt"
$outputFile = "2nd-opinion_formatted.csv"

# Function to replace " = " with commas and convert remaining newlines/line breaks to commas
function ReplaceStringWithCommas($inputString,$bookname) {
	$book = $bookname
	if ($inputString -eq $null) {
		Write-Host "Error when formatting metadata. Data malformed. Halting." -ForegroundColor Red
		break
	} else {
		$commaSeparatedString = $inputString -replace " = ", ""
		$commaSeparatedString = $commaSeparatedString -replace "\n", ","
		$commaSeparatedString = $commaSeparatedString -replace "`n", ","
		$commaSeparatedString = $commaSeparatedString -replace "\r,", ","

		$commaSeparatedString = $commaSeparatedString -replace " dB Max Peaks", ""
		$commaSeparatedString = $commaSeparatedString -replace " dB Average RMS", ""	
		$commaSeparatedString = $commaSeparatedString -replace " Seconds of Silence at Head of File", ""
		$commaSeparatedString = $commaSeparatedString -replace "dB Peak during Head of File", ""
		$commaSeparatedString = $commaSeparatedString -replace "dB Avg RMS during Head of File", ""
		$commaSeparatedString = $commaSeparatedString -replace " Seconds of Silence at Tail of File", ""
		$commaSeparatedString = $commaSeparatedString -replace "dB Peak during Tail of File", ""
		$commaSeparatedString = $commaSeparatedString -replace "dB Avg RMS during Tail of File", ""	
		$commaSeparatedString = $commaSeparatedString -replace " Seconds of Silence at Tail of File", ""
		$commaSeparatedString = $commaSeparatedString -replace " Seconds ", ""	
		$commaSeparatedString = $commaSeparatedString -replace "\(File Runtime\),,",",$book`n"
		$commaSeparatedString = $commaSeparatedString -replace "\(continued\)", "[continued]"
		$commaSeparatedString = $commaSeparatedString -replace "\'", ""		
		#$commaSeparatedString = $commaSeparatedString -replace ",", "\"\,\""
		if ($commaSeparatedString -eq $null) {
			Write-Host "Metadata is an object, not a string. Halting." -ForegroundColor Red
		} else {
			Write-Host "Metadata reformatted successfully." -ForegroundColor DarkGray
			return $commaSeparatedString
		}
	}
}

function Get-2ndOpinionFiles {
	$ProjectData = @()
	$rundir = Get-Location
	$ProjectFiles = (Get-ChildItem -Path $rundir -Filter $inputFile -Recurse -ErrorAction SilentlyContinue -Force)
	
	 if ($rundir -eq $null) {
        Write-Host "**ERROR**: Cannot determine current folder, or access denied." -ForegroundColor Red
        Exit
    } elseif ($ProjectFiles -eq 0) {
		Write-Host "**ERROR**: No report files found in $raw." -ForegroundColor Red
	} else {
		Write-Host $ProjectFiles.Count"reports found:" -ForegroundColor DarkMagenta
		foreach ($reportname in $ProjectFiles) {
			$last2parts = $reportname.FullName.Split("\") | Select-Object -Last 2
			$last2parts = $last2parts -join "\"
			Write-Host "..\"$last2parts -foregroundColor DarkMagenta
		}
		
		foreach ($projectname in $ProjectFiles) {	
			# Read the input text file
			$bookname = @()
			$bookname = $projectname.FullName.Split("\") | Select-Object -Last 2
			Write-Host "`nProcessing: "$bookname[0]

			$textLines = Get-Content $projectname.FullName
			if ($textLines -eq $null) {
				Write-Host "ERROR OPENING REPORT FILE - FILE IS EMPTY." -ForegroundColor Red			
			} else {
				
				Write-Host "File import completed." -foregroundcolor DarkGray

				# Filter out the lines matching exclusion patterns
				$filteredLines = $textLines | Where-Object { -not $_.Contains('***') }
				$filteredLines = $filteredLines | Where-Object { -not $_.Contains('2nd Opinion') }
				$filteredLines = $filteredLines | Where-Object { -not $_.Contains(' - Released') }
				$filteredLines = $filteredLines | Where-Object { -not $_.Contains('A total of') }
				$filteredLines = $filteredLines | Where-Object { -not $_.Contains('RUNTIME:') }
				$filteredLines = $filteredLines | Where-Object { -not $_.Contains('present in the following') }
				$filteredLines = $filteredLines | Where-Object { -not $_.Contains('For assistance,') }
				$filteredLines = $filteredLines | Where-Object { -not $_.Contains('Sample Rate') }
				$filteredLines = $filteredLines | Where-Object { -not $_.Contains('Channel') }				
				if ($filteredLines -eq $null) {
					Write-Host "Error with source file, data format unexpected. Halting." -ForegroundColor Red
					break
				} else {
					Write-Host "Filtering completed successfully." -foregroundcolor DarkGray
				}
				
				$filteredText = $filteredLines | Out-String

				# Replace " = " with commas and convert remaining newlines/line breaks to commas
				$filteredText = ReplaceStringWithCommas $filteredText $bookname[0]
				
				$csvHeader = "Chapter,Max Peaks,Avg RMS,Head Length,Head Peaks,Head RMS,Tail Length,Tail Peaks,Tail RMS,Duration,Title`n"
				$filteredText = $csvHeader + $filteredText

				try {
					$pos = $filteredText.IndexOf("(")
					$leftPart = $filteredText.Substring(0, $pos)
					$rightPart = $filteredText.Substring($pos+1)
					Write-Host "Data trimmed successfully." -foregroundcolor DarkGray
				} catch {
					Write-Host "Cannot trim data after metadata formatting." $Error
				}
				
				# Export the CSV data to a file
				try {
					$bookpath = $projectname.FullName | Split-Path
					$bookpath = $bookpath, $outputFile -join "\"
					echo $leftPart | Out-File $bookpath -Encoding ASCII
					Write-Host "DATA WILL BE SAVED TO: "$bookpath -ForegroundColor DarkGray
				} catch {
					Write-Host "Error saving data." $_ -ForegroundColor Red
				}

			}
		}
	}
}

Write-Host "SEARCHING FOR '2nd-Opinion' REPORT FILES..." -foregroundcolor DarkYellow
Get-2ndOpinionFiles
